/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2017-01-31 15:33:05.905
 */


#ifndef TEST_TYPE_H
#define TEST_TYPE_H
#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"



using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;



namespace com {
	namespace wookler {
		namespace test {
			/**
			* Generated code for data record type test_type.
			*
			* Note:: Should not be modified as the changes will be lost when the code is re-generated.
			*/
			class test_type  : public com::wookler::reactfs::core::types::__base_type
			{
			private:
				const char * testString = nullptr;

				const double * testDouble = nullptr;

				const float * testFloat = nullptr;

				const std::vector<char *> * testListString = nullptr;

				const std::unordered_map<double, char *> * testMapString = nullptr;



				/**
				* Value testString setter from the the serialized data map.
				*
				* @param __data - Serialized data map pointer.
				*/
				void read_value_testString ( const record_struct *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						const void *__ptr = __data->get_field ( 0 );
						if ( NOT_NULL ( __ptr ) ) {
							// Set the value of testString
							const char * __var = static_cast<const char *> ( __ptr );
							CHECK_CAST ( __var, TYPE_NAME ( void * ), TYPE_NAME ( char ) );
							this->testString = __var;

						} else {
							this->testString = nullptr;
						}
					} else {
						this->testString = nullptr;
					}
				}

				/**
				 * Value testDouble setter from the the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void read_value_testDouble ( const record_struct *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						const void *__ptr = __data->get_field ( 1 );
						if ( NOT_NULL ( __ptr ) ) {
							// Set the value of testDouble
							const double * __var = static_cast<const double *> ( __ptr );
							CHECK_CAST ( __var, TYPE_NAME ( void * ), TYPE_NAME ( double ) );
							this->testDouble = __var;

						} else {
							this->testDouble = nullptr;
						}
					} else {
						this->testDouble = nullptr;
					}
				}

				/**
				 * Value testFloat setter from the the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void read_value_testFloat ( const record_struct *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						const void *__ptr = __data->get_field ( 2 );
						if ( NOT_NULL ( __ptr ) ) {
							// Set the value of testFloat
							const float * __var = static_cast<const float *> ( __ptr );
							CHECK_CAST ( __var, TYPE_NAME ( void * ), TYPE_NAME ( float ) );
							this->testFloat = __var;

						} else {
							this->testFloat = nullptr;
						}
					} else {
						this->testFloat = nullptr;
					}
				}

				/**
				 * Value testListString setter from the the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void read_value_testListString ( const record_struct *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						const void *__ptr = __data->get_field ( 3 );
						if ( NOT_NULL ( __ptr ) ) {
							// Set the value of testListString
							const std::vector<char *> * __var = static_cast<const std::vector<char *> *> ( __ptr );
							CHECK_CAST ( __var, TYPE_NAME ( void * ), TYPE_NAME ( vector ) );
							this->testListString = __var;

						} else {
							this->testListString = nullptr;
						}
					} else {
						this->testListString = nullptr;
					}
				}

				/**
				 * Value testMapString setter from the the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void read_value_testMapString ( const record_struct *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						const void *__ptr = __data->get_field ( 4 );
						if ( NOT_NULL ( __ptr ) ) {
							// Set the value of testMapString
							const std::unordered_map<double, char *> * __var = static_cast<const std::unordered_map<double, char *> *> ( __ptr );
							CHECK_CAST ( __var, TYPE_NAME ( void * ), TYPE_NAME ( unordered_map ) );
							this->testMapString = __var;

						} else {
							this->testMapString = nullptr;
						}
					} else {
						this->testMapString = nullptr;
					}
				}


			public:
				/**
				* Get the pointer to the property testString of type char *.
				* Returns a const pointer.
				*
				* @return char *
				*/
				const char * get_testString ( void ) const
				{
					return this->testString;
				}

				/**
				 * Get the pointer to the property testDouble of type double *.
				 * Returns a const pointer.
				 *
				 * @return double *
				 */
				const double * get_testDouble ( void ) const
				{
					return this->testDouble;
				}

				/**
				 * Get the pointer to the property testFloat of type float *.
				 * Returns a const pointer.
				 *
				 * @return float *
				 */
				const float * get_testFloat ( void ) const
				{
					return this->testFloat;
				}

				/**
				 * Get the pointer to the property testListString of type std::vector<char *> *.
				 * Returns a const pointer.
				 *
				 * @return std::vector<char *> *
				 */
				const std::vector<char *> * get_testListString ( void ) const
				{
					return this->testListString;
				}

				/**
				 * Get the pointer to the property testMapString of type std::unordered_map<double, char *> *.
				 * Returns a const pointer.
				 *
				 * @return std::unordered_map<double, char *> *
				 */
				const std::unordered_map<double, char *> * get_testMapString ( void ) const
				{
					return this->testMapString;
				}

				/**
				 * Create a new read-only instance of test_type.
				 *
				 * Type to be used when instance is being de-serialized from record data.
				 */
				test_type()
				{
					this->testString = nullptr;
					this->testDouble = nullptr;
					this->testFloat = nullptr;
					this->testListString = nullptr;
					this->testMapString = nullptr;

				}

				/**
				 * Descructor for test_type
				 */
				~test_type()
				{

				}

				/**
				 * Deserialize this type instance from the passed data map.
				 *
				 * @param __data - Serialized data record instance to load this type from.
				 */
				void deserialize ( const record_struct *__data ) override
				{
					CHECK_NOT_NULL ( __data );

					this->record_type = __data->get_record_type();
					CHECK_NOT_NULL ( this->record_type );

					// Set the value of testString from the serialized data map.
					this->read_value_testString ( __data );

					// Set the value of testDouble from the serialized data map.
					this->read_value_testDouble ( __data );

					// Set the value of testFloat from the serialized data map.
					this->read_value_testFloat ( __data );

					// Set the value of testListString from the serialized data map.
					this->read_value_testListString ( __data );

					// Set the value of testMapString from the serialized data map.
					this->read_value_testMapString ( __data );



					this->__data = __data;
				}

				/**
				 * Compare this type instance to the passed instance.
				 *
				 * @param __target - Target instance to compare with. If pointer is not
				 * 			of the same type will throw exception.
				 * @return - Is equal?
				 */
				bool equals ( const void* __target ) const override
				{
					if ( IS_NULL ( __target ) ) {
						return false;
					}
					const test_type * __t = static_cast<const test_type *> ( __target );
					CHECK_CAST ( __t, TYPE_NAME ( void * ), TYPE_NAME ( test_type * ) );

					{
						// Compare field testString
						const __native_type *nt = get_field_type ( "testString" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = __t->get_testString();
						const void *sv = this->get_testString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare field testDouble
						const __native_type *nt = get_field_type ( "testDouble" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = __t->get_testDouble();
						const void *sv = this->get_testDouble();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare field testFloat
						const __native_type *nt = get_field_type ( "testFloat" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = __t->get_testFloat();
						const void *sv = this->get_testFloat();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare list instance testListString
						const vector<char *> *tv = __t->get_testListString();
						const vector<char *> *sv = this->get_testListString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( tv ) && NOT_NULL ( sv ) ) {
							if ( tv->size() != sv->size() ) {
								return false;
							}
							const __native_type *nt = get_field_type ( "testListString" );
							CHECK_NOT_NULL ( nt );

							PRECONDITION ( nt->get_type() == __field_type::LIST );
							const __list_type *lt = dynamic_cast<const __list_type *> ( nt );
							CHECK_CAST ( lt, TYPE_NAME ( __native_type ), TYPE_NAME ( __list_type ) );

							// Get type handler for inner type.
							__base_datatype_io *th = lt->get_inner_type()->get_type_handler ( __record_mode::RM_READ );
							CHECK_NOT_NULL ( th );

							for ( uint32_t ii = 0; ii < tv->size(); ii++ ) {
								const void *v1 = ( *sv ) [ii];
								const void *v2 = ( *tv ) [ii];
								if ( IS_NULL ( v1 ) ) {
									if ( NOT_NULL ( v2 ) ) {
										return false;
									}
									continue;
								}

								bool r = th->compare ( v2, v1, __constraint_operator::EQ );
								if ( !r ) {
									return false;
								}
							}
						}
					}

					{
						// Compare map instance testMapString
						const unordered_map<double, char *> *tv = __t->get_testMapString();
						const unordered_map<double, char *> *sv = this->get_testMapString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( tv ) && NOT_NULL ( sv ) ) {
							if ( tv->size() != sv->size() ) {
								return false;
							}

							const __native_type *nt = get_field_type ( "testMapString" );
							CHECK_NOT_NULL ( nt );

							PRECONDITION ( nt->get_type() == __field_type::MAP );
							const __map_type *mt = dynamic_cast<const __map_type *> ( nt );
							CHECK_CAST ( mt, TYPE_NAME ( __native_type ), TYPE_NAME ( __map_type ) );

							// Get type handler for value type.
							__base_datatype_io *th = mt->get_value_type()->get_type_handler ( __record_mode::RM_READ );
							CHECK_NOT_NULL ( th );

							unordered_map<double, char *>::const_iterator iter_t;
							unordered_map<double, char *>::const_iterator iter_s;

							for ( iter_s = sv->begin(); iter_s != sv->end(); iter_s++ ) {
								iter_t = tv->find ( iter_s->first );
								if ( iter_t == tv->end() ) {
									return false;
								}
								const void *v1 = iter_s->second;
								const void *v2 = iter_t->second;
								if ( IS_NULL ( v1 ) ) {
									if ( NOT_NULL ( v2 ) ) {
										return false;
									}
									continue;
								}

								bool r = th->compare ( v2, v1, __constraint_operator::EQ );
								if ( !r ) {
									return false;
								}
							}
						}
					}



					return true;
				}


			};


			/**
			 * Generated code for data record type mutable_test_type.
			 *
			 * Note:: Should not be modified as the changes will be lost when the code is re-generated.
			 */
			class mutable_test_type  : public com::wookler::reactfs::core::types::__mutable_base_type
			{
			private:
				char * testString = nullptr;

				double * testDouble = nullptr;

				float * testFloat = nullptr;

				std::vector<char *> * testListString = nullptr;

				std::unordered_map<double, char *> * testMapString = nullptr;



				/**
				* Method extracts and set the value of testString from
				* the serialized data map.
				*
				* @param __data - Serialized data map pointer.
				*/
				void set_serde_testString ( mutable_record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->testString ) ) {
						// Add the value of testString to the data map.
						{
							const __native_type *ft = get_field_type ( "testString" );
							CHECK_NOT_NULL ( ft );
							__data->add_field ( ft->get_index(), this->testString );

						}

					}
				}

				/**
				 * Method extracts and set the value of testDouble from
				 * the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void set_serde_testDouble ( mutable_record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->testDouble ) ) {
						// Add the value of testDouble to the data map.
						{
							const __native_type *ft = get_field_type ( "testDouble" );
							CHECK_NOT_NULL ( ft );
							__data->add_field ( ft->get_index(), this->testDouble );

						}

					}
				}

				/**
				 * Method extracts and set the value of testFloat from
				 * the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void set_serde_testFloat ( mutable_record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->testFloat ) ) {
						// Add the value of testFloat to the data map.
						{
							const __native_type *ft = get_field_type ( "testFloat" );
							CHECK_NOT_NULL ( ft );
							__data->add_field ( ft->get_index(), this->testFloat );

						}

					}
				}

				/**
				 * Method extracts and set the value of testListString from
				 * the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void set_serde_testListString ( mutable_record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->testListString ) ) {
						// Add the value of testListString to the data map.
						{
							const __native_type *ft = get_field_type ( "testListString" );
							CHECK_NOT_NULL ( ft );
							__data->add_field ( ft->get_index(), this->testListString );

						}

					}
				}

				/**
				 * Method extracts and set the value of testMapString from
				 * the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void set_serde_testMapString ( mutable_record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->testMapString ) ) {
						// Add the value of testMapString to the data map.
						{
							const __native_type *ft = get_field_type ( "testMapString" );
							CHECK_NOT_NULL ( ft );
							__data->add_field ( ft->get_index(), this->testMapString );

						}

					}
				}


			public:
				/**
				* Set the pointer to testString.
				*
				* @param testString - Pointer of type char *.
				*/
				void set_testString ( char * testString )
				{
					this->testString = testString;
				}

				/**
				 * Get the pointer to the property testString of type char *.
				 * Returns a const pointer.
				 *
				 * @return char *
				 */
				const char * get_testString ( void ) const
				{
					return this->testString;
				}

				/**
				 * Set the char buffer value from the specified string.
				 *
				 * Method should only be used when this instance is being
				 * used to create or update a new record instance.
				 *
				 * @param testString - String value to set.
				 */
				void set_testString ( const string &testString )
				{
					FREE_PTR ( this->testString );
					if ( !IS_EMPTY ( testString ) ) {
						uint32_t __size = testString.length() + 1;
						this->testString = ( char * ) malloc ( sizeof ( char ) * __size );
						CHECK_ALLOC ( this->testString, TYPE_NAME ( char * ) );
						memset ( this->testString, 0, __size );
						memcpy ( this->testString, testString.c_str(), ( __size - 1 ) );
					}
				}

				/**
				 * Set the pointer to testDouble.
				 *
				 * @param testDouble - Pointer of type double *.
				 */
				void set_testDouble ( double * testDouble )
				{
					this->testDouble = testDouble;
				}

				/**
				 * Get the pointer to the property testDouble of type double *.
				 * Returns a const pointer.
				 *
				 * @return double *
				 */
				const double * get_testDouble ( void ) const
				{
					return this->testDouble;
				}

				/**
				 * Set the value to testDouble.
				 *
				 * Method should only be used when this instance is being
				 * used to create or update a new record instance.
				 *
				 * @Param testDouble - Value reference.
				 */
				void set_testDouble ( const double &testDouble )
				{
					if ( IS_NULL ( this->testDouble ) ) {
						this->testDouble = ( double * ) malloc ( sizeof ( double ) );
						CHECK_ALLOC ( this->testDouble, TYPE_NAME ( double ) );
					}
					* ( this->testDouble ) = testDouble;
				}

				/**
				 * Set the pointer to testFloat.
				 *
				 * @param testFloat - Pointer of type float *.
				 */
				void set_testFloat ( float * testFloat )
				{
					this->testFloat = testFloat;
				}

				/**
				 * Get the pointer to the property testFloat of type float *.
				 * Returns a const pointer.
				 *
				 * @return float *
				 */
				const float * get_testFloat ( void ) const
				{
					return this->testFloat;
				}

				/**
				 * Set the value to testFloat.
				 *
				 * Method should only be used when this instance is being
				 * used to create or update a new record instance.
				 *
				 * @Param testFloat - Value reference.
				 */
				void set_testFloat ( const float &testFloat )
				{
					if ( IS_NULL ( this->testFloat ) ) {
						this->testFloat = ( float * ) malloc ( sizeof ( float ) );
						CHECK_ALLOC ( this->testFloat, TYPE_NAME ( float ) );
					}
					* ( this->testFloat ) = testFloat;
				}

				/**
				 * Get the pointer to the property testListString of type std::vector<char *> *.
				 * Returns a const pointer.
				 *
				 * @return std::vector<char *> *
				 */
				const std::vector<char *> * get_testListString ( void ) const
				{
					return this->testListString;
				}

				/**
				 * Set the pointer to testListString.
				 *
				 * @param testListString - Pointer of type std::vector<char *> *.
				 */
				void set_testListString ( std::vector<char *> * testListString )
				{
					this->testListString = testListString;
				}

				/**
				 * Add a string element to the list testListString.
				 * Elements are expected to be pre-assigned data
				 * value.
				 *
				 * Method should only be used when this instance is being
				 * used to create or update a new record instance.
				 *
				 * @param testListString - String value to add to list.
				 */
				void add_to_testListString ( const string &testListString )
				{
					if ( IS_NULL ( this->testListString ) ) {
						this->testListString = new std::vector<char *>();
						CHECK_ALLOC ( this->testListString, TYPE_NAME ( vector ) );
					}
					if ( !IS_EMPTY ( testListString ) ) {
						uint32_t __size = testListString.length() + 1;
						char *__var = ( char * ) malloc ( sizeof ( char ) * __size );
						CHECK_ALLOC ( __var, TYPE_NAME ( char * ) );
						memset ( __var, 0, __size );
						memcpy ( __var, testListString.c_str(), ( __size - 1 ) );
						this->testListString->push_back ( __var );
					}
				}

				/**
				 * Get the pointer to the property testMapString of type std::unordered_map<double, char *> *.
				 * Returns a const pointer.
				 *
				 * @return std::unordered_map<double, char *> *
				 */
				const std::unordered_map<double, char *> * get_testMapString ( void ) const
				{
					return this->testMapString;
				}

				/**
				 * Set the pointer to testMapString.
				 *
				 * @param testMapString - Pointer of type std::unordered_map<double, char *> *.
				 */
				void set_testMapString ( std::unordered_map<double, char *> * testMapString )
				{
					this->testMapString = testMapString;
				}

				/**
				 * Add a map record of key/value type double/char *.
				 *
				 * @param m_key - Map key of type double
				 * @param m_value - String value of the map record value.
				 */
				void add_to_testMapString ( const double m_key, const string &m_value )
				{
					if ( IS_NULL ( this->testMapString ) ) {
						this->testMapString = new std::unordered_map<double, char *>();
						CHECK_ALLOC ( this->testMapString, TYPE_NAME ( unordered_map ) );
					}
					CHECK_NOT_EMPTY ( m_value );
					uint32_t __size = ( m_value.length() + 1 ) * sizeof ( char );
					char *__var = ( char * ) malloc ( sizeof ( char ) * __size );
					CHECK_ALLOC ( __var, TYPE_NAME ( char * ) );
					memset ( __var, 0, __size );
					memcpy ( __var, m_value.c_str(), ( __size - 1 ) );
					this->testMapString->insert ( {m_key, __var} );
				}

				/**
				 * Empty constructor when creating an instance of mutable_test_type for setting data locally.
				 * Should be used to create a new record instance of type mutable_test_type.
				 *
				 * @param record_type - Parsed schema definition of this type.
				 */
				mutable_test_type ( const __complex_type *record_type )
				{
					CHECK_NOT_NULL ( record_type );
					this->record_type = record_type;

					this->testString = nullptr;
					this->testDouble = nullptr;
					this->testFloat = nullptr;
					this->testListString = nullptr;
					this->testMapString = nullptr;

				}

				/**
				 * Copy constructor to create a copy instance of mutable_test_type.
				 * Copy instances should be used to update existing records.
				 *
				 * @param source - Source instance of mutable_test_type to copy from.
				 */
				mutable_test_type ( const test_type &source )
				{
					this->record_type = source.get_record_type();
					CHECK_NOT_NULL ( this->record_type );

					this->testString = nullptr;
					this->testDouble = nullptr;
					this->testFloat = nullptr;
					this->testListString = nullptr;
					this->testMapString = nullptr;

					// Set testString from the source value.
					if ( NOT_NULL ( source.get_testString() ) ) {
						string __testString = string ( source.get_testString() );
						this->set_testString ( __testString );
					}

// Set testDouble from the source value.
					if ( NOT_NULL ( source.get_testDouble() ) ) {
						this->set_testDouble ( * ( source.get_testDouble() ) );
					}

// Set testFloat from the source value.
					if ( NOT_NULL ( source.get_testFloat() ) ) {
						this->set_testFloat ( * ( source.get_testFloat() ) );
					}

// Deserialize the list testListString from the source value.
					if ( NOT_EMPTY_P ( source.get_testListString() ) ) {
						std::vector<char *> *__list = new std::vector<char *>();
						CHECK_ALLOC ( __list, TYPE_NAME ( vector ) );
						for ( const char * v : * ( source.get_testListString() ) ) {
							CHECK_NOT_NULL ( v );
							char * __tv = ( char * ) malloc ( sizeof ( char ) );
							CHECK_ALLOC ( __tv, TYPE_NAME ( char ) );
							*__tv = *v;
							__list->push_back ( __tv );
						}
						this->testListString = __list;
					}

// Deserialize the map testMapString from the source value.
					if ( NOT_EMPTY_P ( source.get_testMapString() ) ) {
						std::unordered_map<double, char *> *__map = new std::unordered_map<double, char *>();
						CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

						const std::unordered_map<double, char *> *__s_map = source.get_testMapString();
						std::unordered_map<double, char * >::const_iterator iter;
						for ( iter = __s_map->begin(); iter != __s_map->end(); iter++ ) {
							CHECK_NOT_NULL ( iter->second );
							char * __tv = ( char * ) malloc ( sizeof ( char ) );
							CHECK_ALLOC ( __tv, TYPE_NAME ( char ) );
							*__tv = * ( iter->second );
							__map->insert ( {iter->first, __tv} );
						}
						this->testMapString = __map;
					}


				}

				/**
				 * Copy constructor to create a copy instance of mutable_test_type.
				 * Copy instances should be used to update existing records.
				 *
				 * @param source - Source instance of mutable_test_type to copy from.
				 */
				mutable_test_type ( const test_type *source )
				{
					this->record_type = source->get_record_type();
					CHECK_NOT_NULL ( this->record_type );

					this->testString = nullptr;
					this->testDouble = nullptr;
					this->testFloat = nullptr;
					this->testListString = nullptr;
					this->testMapString = nullptr;

					// Set testString from the source value.
					if ( NOT_NULL ( source->get_testString() ) ) {
						string __testString = string ( source->get_testString() );
						this->set_testString ( __testString );
					}

// Set testDouble from the source value.
					if ( NOT_NULL ( source->get_testDouble() ) ) {
						this->set_testDouble ( * ( source->get_testDouble() ) );
					}

// Set testFloat from the source value.
					if ( NOT_NULL ( source->get_testFloat() ) ) {
						this->set_testFloat ( * ( source->get_testFloat() ) );
					}

// Deserialize the list testListString from the source value.
					if ( NOT_EMPTY_P ( source->get_testListString() ) ) {
						std::vector<char *> *__list = new std::vector<char *>();
						CHECK_ALLOC ( __list, TYPE_NAME ( vector ) );
						for ( const char * v : * ( source->get_testListString() ) ) {
							CHECK_NOT_NULL ( v );
							char * __tv = ( char * ) malloc ( sizeof ( char ) );
							CHECK_ALLOC ( __tv, TYPE_NAME ( char ) );
							*__tv = *v;
							__list->push_back ( __tv );
						}
						this->testListString = __list;
					}

// Deserialize the map testMapString from the source value.
					if ( NOT_EMPTY_P ( source->get_testMapString() ) ) {
						std::unordered_map<double, char *> *__map = new std::unordered_map<double, char *>();
						CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

						const std::unordered_map<double, char * > *__s_map = source->get_testMapString();
						std::unordered_map<double, char * >::const_iterator iter;
						for ( iter = __s_map->begin(); iter != __s_map->end(); iter++ ) {
							CHECK_NOT_NULL ( iter->second );
							char * __tv = ( char * ) malloc ( sizeof ( char ) );
							CHECK_ALLOC ( __tv, TYPE_NAME ( char ) );
							*__tv = * ( iter->second );
							__map->insert ( {iter->first, __tv} );
						}
						this->testMapString = __map;
					}


				}

				/**
				 * Descructor for mutable_test_type
				 */
				~mutable_test_type()
				{
					FREE_PTR ( this->testString );

					FREE_PTR ( this->testDouble );

					FREE_PTR ( this->testFloat );

					FREE_NATIVE_LIST ( this->testListString );

					FREE_NATIVE_MAP ( this->testMapString );


				}

				/**
				 * Serialize this type instance into a data map instance.
				 *
				 * @return - Serialized data record instance.
				 */
				mutable_record_struct *serialize() override
				{
					mutable_record_struct *__data = new mutable_record_struct ( this->record_type );
					CHECK_ALLOC ( __data, TYPE_NAME ( mutable_record_struct ) );
					// Call the method to add the value of testString to the serialized data map.
					this->set_serde_testString ( __data );

// Call the method to add the value of testDouble to the serialized data map.
					this->set_serde_testDouble ( __data );

// Call the method to add the value of testFloat to the serialized data map.
					this->set_serde_testFloat ( __data );

// Call the method to add the value of testListString to the serialized data map.
					this->set_serde_testListString ( __data );

// Call the method to add the value of testMapString to the serialized data map.
					this->set_serde_testMapString ( __data );


					return __data;
				}

				/**
				 * Compare this type instance to the passed instance.
				 *
				 * @param __target - Target instance to compare with. If pointer is not
				 * 			of the same type will throw exception.
				 * @return - Is equal?
				 */
				bool equals ( const void* __target ) const override
				{
					if ( IS_NULL ( __target ) ) {
						return false;
					}
					const mutable_test_type * __t = static_cast<const mutable_test_type *> ( __target );
					CHECK_CAST ( __t, TYPE_NAME ( void * ), TYPE_NAME ( mutable_test_type * ) );

					{
						// Compare field testString
						const __native_type *nt = get_field_type ( "testString" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = __t->get_testString();
						const void *sv = this->get_testString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare field testDouble
						const __native_type *nt = get_field_type ( "testDouble" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = __t->get_testDouble();
						const void *sv = this->get_testDouble();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare field testFloat
						const __native_type *nt = get_field_type ( "testFloat" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = __t->get_testFloat();
						const void *sv = this->get_testFloat();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare list instance testListString
						const vector<char *> *tv = __t->get_testListString();
						const vector<char *> *sv = this->get_testListString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( tv ) && NOT_NULL ( sv ) ) {
							if ( tv->size() != sv->size() ) {
								return false;
							}
							const __native_type *nt = get_field_type ( "testListString" );
							CHECK_NOT_NULL ( nt );

							PRECONDITION ( nt->get_type() == __field_type::LIST );
							const __list_type *lt = dynamic_cast<const __list_type *> ( nt );
							CHECK_CAST ( lt, TYPE_NAME ( __native_type ), TYPE_NAME ( __list_type ) );

							// Get type handler for inner type.
							__base_datatype_io *th = lt->get_inner_type()->get_type_handler ( __record_mode::RM_READ );
							CHECK_NOT_NULL ( th );

							for ( uint32_t ii = 0; ii < tv->size(); ii++ ) {
								const void *v1 = ( *sv ) [ii];
								const void *v2 = ( *tv ) [ii];
								if ( IS_NULL ( v1 ) ) {
									if ( NOT_NULL ( v2 ) ) {
										return false;
									}
									continue;
								}

								bool r = th->compare ( v2, v1, __constraint_operator::EQ );
								if ( !r ) {
									return false;
								}
							}
						}
					}

					{
						// Compare map instance testMapString
						const unordered_map<double, char *> *tv = __t->get_testMapString();
						const unordered_map<double, char *> *sv = this->get_testMapString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( tv ) && NOT_NULL ( sv ) ) {
							if ( tv->size() != sv->size() ) {
								return false;
							}

							const __native_type *nt = get_field_type ( "testMapString" );
							CHECK_NOT_NULL ( nt );

							PRECONDITION ( nt->get_type() == __field_type::MAP );
							const __map_type *mt = dynamic_cast<const __map_type *> ( nt );
							CHECK_CAST ( mt, TYPE_NAME ( __native_type ), TYPE_NAME ( __map_type ) );

							// Get type handler for value type.
							__base_datatype_io *th = mt->get_value_type()->get_type_handler ( __record_mode::RM_READ );
							CHECK_NOT_NULL ( th );

							unordered_map<double, char *>::const_iterator iter_t;
							unordered_map<double, char *>::const_iterator iter_s;

							for ( iter_s = sv->begin(); iter_s != sv->end(); iter_s++ ) {
								iter_t = tv->find ( iter_s->first );
								if ( iter_t == tv->end() ) {
									return false;
								}
								const void *v1 = iter_s->second;
								const void *v2 = iter_t->second;
								if ( IS_NULL ( v1 ) ) {
									if ( NOT_NULL ( v2 ) ) {
										return false;
									}
									continue;
								}

								bool r = th->compare ( v2, v1, __constraint_operator::EQ );
								if ( !r ) {
									return false;
								}
							}
						}
					}



					return true;
				}


			};


			/**
			 * Generated code for type comparison utility for test_type.
			 *
			 * Note:: Should not be modified as the changes will be lost when the code is re-generated.
			 */
			class compare_test_type
			{
			public:
				static bool equals ( const test_type * source, const mutable_test_type * target )
				{
					if ( IS_NULL ( source ) ) {
						if ( IS_NULL ( target ) ) {
							return true;
						}
						return false;
					}

					{
						// Compare native field testString
						const __native_type *nt = source->get_field_type ( "testString" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = source->get_testString();
						const void *sv = target->get_testString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare native field testDouble
						const __native_type *nt = source->get_field_type ( "testDouble" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = source->get_testDouble();
						const void *sv = target->get_testDouble();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare native field testFloat
						const __native_type *nt = source->get_field_type ( "testFloat" );
						CHECK_NOT_NULL ( nt );
						__base_datatype_io *th = nt->get_type_handler ( __record_mode::RM_READ );
						CHECK_NOT_NULL ( th );
						const void *tv = source->get_testFloat();
						const void *sv = target->get_testFloat();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( sv ) && NOT_NULL ( tv ) ) {
							bool r = th->compare ( tv, sv, __constraint_operator::EQ );
							if ( !r ) {
								return false;
							}
						}
					}

					{
						// Compare list instance testListString
						const vector<char *> *tv = source->get_testListString();
						const vector<char *> *sv = target->get_testListString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( tv ) && NOT_NULL ( sv ) ) {
							if ( tv->size() != sv->size() ) {
								return false;
							}
							const __native_type *nt = source->get_field_type ( "testListString" );
							CHECK_NOT_NULL ( nt );

							PRECONDITION ( nt->get_type() == __field_type::LIST );
							const __list_type *lt = dynamic_cast<const __list_type *> ( nt );
							CHECK_CAST ( lt, TYPE_NAME ( __native_type ), TYPE_NAME ( __list_type ) );

							// Get type handler for inner type.
							__base_datatype_io *th = lt->get_inner_type()->get_type_handler ( __record_mode::RM_READ );
							CHECK_NOT_NULL ( th );

							for ( uint32_t ii = 0; ii < tv->size(); ii++ ) {
								const void *v1 = ( *sv ) [ii];
								const void *v2 = ( *tv ) [ii];
								if ( IS_NULL ( v1 ) ) {
									if ( NOT_NULL ( v2 ) ) {
										return false;
									}
									continue;
								}

								bool r = th->compare ( v2, v1, __constraint_operator::EQ );
								if ( !r ) {
									return false;
								}
							}
						}

					}

					{
						// Compare map instance testMapString
						const unordered_map<double, char *> *tv = source->get_testMapString();
						const unordered_map<double, char *> *sv = target->get_testMapString();
						if ( IS_NULL ( sv ) ) {
							if ( NOT_NULL ( tv ) ) {
								return false;
							}
						}
						if ( NOT_NULL ( tv ) && NOT_NULL ( sv ) ) {
							if ( tv->size() != sv->size() ) {
								return false;
							}

							const __native_type *nt = source->get_field_type ( "testMapString" );
							CHECK_NOT_NULL ( nt );

							PRECONDITION ( nt->get_type() == __field_type::MAP );
							const __map_type *mt = dynamic_cast<const __map_type *> ( nt );
							CHECK_CAST ( mt, TYPE_NAME ( __native_type ), TYPE_NAME ( __map_type ) );

							// Get type handler for value type.
							__base_datatype_io *th = mt->get_value_type()->get_type_handler ( __record_mode::RM_READ );
							CHECK_NOT_NULL ( th );

							unordered_map<double, char *>::const_iterator iter_t;
							unordered_map<double, char *>::const_iterator iter_s;

							for ( iter_s = sv->begin(); iter_s != sv->end(); iter_s++ ) {
								iter_t = tv->find ( iter_s->first );
								if ( iter_t == tv->end() ) {
									return false;
								}
								const void *v1 = iter_s->second;
								const void *v2 = iter_t->second;
								if ( IS_NULL ( v1 ) ) {
									if ( NOT_NULL ( v2 ) ) {
										return false;
									}
									continue;
								}

								bool r = th->compare ( v2, v1, __constraint_operator::EQ );
								if ( !r ) {
									return false;
								}
							}
						}
					}



					return true;
				}

			};


		}

	}

}

#endif // TEST_TYPE_H

